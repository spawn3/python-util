\chapter{实现相关}

\begin{compactitem}
    \item polling \change{polling}
    \item coroutine and scheduler
    \item mbuffer
    \item kernel bypass
\end{compactitem}

\section{Protocol}

Protocol与存储卷是正交功能。protocol应该独立于卷进行扩展。
所以，path中包含protocol组件，并非必须，而是实现上的权宜之计。

\section{Algorithm}

\begin{compactitem}
    \item paxos/raft 选举admin和meta节点
    \item vector clock 副本一致性
    \item lease controller的唯一性
\end{compactitem}

\section{Coroutine}

使用规则：
\begin{compactitem}
    \item \verb|schedule_task_get|和\verb|schedule_yield|要匹配
    \item task有数量上的限制：1024，超出后容易引起死锁
\end{compactitem}

\section{AIO}

生产者-消费者模型。

\section{sqlite3}

异步sqlite3。

\begin{compactitem}
    \item 共10个db，每个一个线程，每个线程管理一个队列
    \item 所有sqlite3操作，泛化为统一的结构，放入线程队列
    \item 消费者线程批量处理队列中的任务
    \item 生产者线程和消费者线程通过sem进行通信
    \item 采用协程机制(yield/resume)同步任务执行顺序
\end{compactitem}

消费者线程wait在sem上，生产者线程有消息的时候，调用\verb|sem_post|。

\section{编程注意事项}

\begin{compactitem}
\item goto之前，先设置ret
\end{compactitem}

\section{Performance}

4K+1M混合读写，极慢

机械盘关闭localize

\subsection{Lease}

利用lease机制来保证volume controller的唯一性。

加载卷时，尝试创建lease，成功后才能执行加载过程。

若没有IO，如果发生lease超时，admin会回收发生超时的lease。后续如有IO，需要重新申请。

如同锁一样，lease会发生抢占。lease是带timeout的锁。现在的实现，需要client去频繁检查，而不是通知机制。

（心跳，向量时钟，版本）能改善?

通过VIP机制，访问卷控制器的过程，与不同VIP，有所不同。

EREMCHG错误主要用于控制器发生切换的时候。

\subsection{Hash}

chkid如何选择hash函数？

\subsection{分支预测}

\subsection{Profile}

lich.conf: performance\_analysis: on

kill -USR1 <pid>

tail -f /opt/fusionstack/log/lich.log |grep analysis

\section{故障}

下电，感知有一定延迟，tcp timeout。

重新选举admin

\section{Safe Mode}

卷级进行检查，处在保护模式的卷，不允许iscsi连接，返回错误码。

加载时间较长的模块，用half sync/half async模式来处理。分为两阶段：同步+异步。

一个卷，加载成功，依赖于几个条件：
\begin{compactitem}
    \item raw/lsv
    \item module load
\end{compactitem}

\section{Log}

syslog

日志过滤

统计数据：准确性和实时性

