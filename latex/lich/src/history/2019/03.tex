\section{03}

\hrulefill

范畴化和做类比是认知的核心。RMI原则揭示了这一点。

一致性问题是重中之重。

lich卷提供了类似disk的服务。需要应用层做出补偿。
分别分析单disk、单节点，集群整体掉电的情况。

与raft做类比：leader选举，如何找到leader？日志恢复、正常服务几个阶段。

如何定义提交规则？如何apply到apply？lich保证了提交的持久性，
对uncommitted条目，如何分析其安全性？

nid,magic作为epoch，避免ABA问题。clock/dirty的管理规则

CAS/ABA是个需要重点理解的知识点，lock free ring就是基于类似的原子操作实现的。

多处理器编程的艺术

C++并发编程实战

FS/数据库的一致性

\hrulefill

写和读具有共轭关系。卷的读写就是所谓I/O。

\hl{一个IO可能涉及多个chunk，如何防撕裂？范围锁？}

COW快照的snaptree上，每个阶段记录了该节点到下一节点的变更原像，这是严格按照快照定义得到的。
任何一快照，都保留了该时间点的卷的状态。

考量一个极端情况，一直打快照，而无变更，所有快照的数据均为空。revert和delete都没有太多工作要做。

读卷和读快照有着本质上的不同。读卷不受影响，因为卷上一直有着最新的全部数据。
读快照则不然，需要两步：读该快照及其下游节点，读最低公共祖先到卷所在路径上的节点。

何时需要读快照？revert和clone时。区分读快照与读单个快照。

由此可推到读快照的过程。COW快照能有全量索引吗？有没有更好的做法？

引入auto snap主要是为了节约空间，如果存入snap from，则后续无法区分并清理。

\hrulefill

ROW的快照则保存的是打快照时的卷，相当于双缓冲区，新的写入发生在新的缓冲区。
读卷和读快照都变得复杂，revert和delete操作也需具体分析。

有特殊的情况可以简化删除过程。分解几种情况：如果快照是一个叶子节点，可直接delete，
如果是中间节点或根节点，最简单的方式就是标记删除。
