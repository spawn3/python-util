\section{02}

\subsection{02}

\hl{Reactive Programming与CAP关系密切}。追求的value是即时响应、可维护性和可扩展性。在正常情况下是如此，即便发生故障，或负载变化，也是如此。
如何做到？引入了async、non-blocking消息传递，引入了显式的消息队列。通过MQ，如何实现以上诸特性呢？

系统划分成组件树的成绩结构，明确职责、隔离故障，并把故障委托给独立的故障处理单元。

\hrulefill

Lich的故障处理，应该有一套框架去处理所有故障，包括磁盘、节点，甚至把balance也纳入其中。
通过发送消息来触发相应的处理逻辑。

维护显式的消息队列，放在哪儿？client端，卷控端？如放在卷控端，由谁来调度执行？
卷控实则是个非执行体，只是一个内存结构。

可以由卷控所在的core线程去调度、或采用timer的方式。

MQ的task之间，如果由依赖关系，如io读写请求，需要同步机制。

并发提交的每个请求对应一coroutine，在scheduler层面，形成了一MQ。

\hrulefill

Lich的task，与actor有很多不同，如没有mailbox，不能形成监督树。
