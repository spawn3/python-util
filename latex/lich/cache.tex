\chapter{缓存}

\section{Redis Cache}

卷控制器所在节点，IO入口处，分页。当切换卷控制器的时候，清空redis cache。

采用redis LRU或FRU算法。

\begin{compactitem}
    \item \verb|volume_proto_write|
    \item \verb|volume_proto_read|
\end{compactitem}

read过程，从io的两段向中间压缩，选取中间最大的加载区。

若发生volume controller切换，源端能否及时感知该事件，会有清理过程吗？怎么使源端的cache数据失效？
在cache里，有两级检查机制：卷和页。有总开关，分级，如果设定卷级状态失效，则全体页也是失效的。

为什么会发生volume controller切换？主动move，节点故障，iscsi session切换等。

切走，失效化，切回。如果在切回之前没有失效化，则有\hl{cache一致性问题}。

如何检测到该事件？

\begin{tcolorbox}
每发生一次切换，\verb|info_version|即+1，在redis key里加入该信息。
利用redis自身的置换机制，则切换不会造成cache一致性问题。
\end{tcolorbox}

\begin{compactenum}
\item config: \hl{功能开关}
\item 初始化
\item \verb|info_version|
\item 并发
\item 内存copy
\item batch update redis (mset and mget)
\item 存在，则不kset？
\item redis连接可以用unix domain，相比tcp方式提速1倍左右
\end{compactenum}

遗留问题：
\begin{enumbox}
\item 顺序读，分页后，性能下降
\item 随机读，破坏局部性
\item 内存cache？
\item 必须考虑基准性能，SSD read和redis read，IOPS哪个多？
\end{enumbox}

即使是连接本地redis，tcp开销也是很大的，最多3w IOPS。如果缓存命中率低，或者分页引起的tcp开销，反而会导致读写性能下降。

实现cache有一些通用问题和瓶颈，可以提前指出。
