\chapter{Volume}

\section{属性}

\begin{lstlisting}[language=c,frame=single]
typedef struct {
        fileid_t id;
        uint16_t magic;
        uint16_t repnum;
        uint64_t snap_rollback;
        uint64_t snap_version;
        uint64_t reference;         //clone reference
        uint32_t attr;
        int32_t  priority;
        uint32_t __pad__[4];

        uint64_t size;
        uint32_t mode;
        uint32_t uid;
        uint32_t gid;
        uint32_t ctime;
        uint32_t mtime;
        uint32_t btime;
        uint32_t atime;
} fileinfo_t;
\end{lstlisting}

卷是ServerSAN核心对象，是pool，snapshot，mapping和cg的中心。

卷的属性记录在L1 chunk的fileinfo段。fileinfo段是vol info区的第一个段。

\subsection{大小}

目前，卷的元数据由两级组成：L1，L2。L1只有一个chunk，每个chunk有8000个槽位。每个槽位指向一个L2 chunk。
L2 chunk有16000个槽位，每个槽位指向一个raw chunk。所以，最大卷大小约为$122TB = 8000 \times 16000 \times 1MB$。

为了支持更大的卷，需要扩展此结构，把L1扩展到多个chunk。改变会影响到：
\begin{compactitem}
\item 加载table1 (加载多个chunk，记录每个chunk的chunkinfo信息)
\item table1的各项操作
\item 遍历卷的chunk
\item 数据恢复过程
\item migrate
\item copy
\item snapshot clone，需要copy L1 chunk
\item ...
\end{compactitem}

L1 chunk：vol.xxx.0, vol.xxx.1, vol.xxx.2。其中，vol.xxx.0的chunkinfo记录在pool。
\hl{vol.xxx.1等chunkinfo记录到vol.xxx.0里info区的第二个块，并需记录其个数}。动态加载。

父：raw和subvol的父chkid为vol.xxx.0，vol.xxx.1的父chkid也为vol.xxx.0。vol.xxx.0的父chkid为所在pool的chkid。

缺页中断：从上到下检查。创建chunk的时候，先检查L1 chunk是否存在，然后检查L2 chunk是否存在。
不存在，则创建。在以下过程会改变卷的数据结构树：
\begin{compactitem}
\item \verb|__pool_proto_mkvol|
\item \verb|volume_proto_load|
\item \verb|volume_proto_chunk_pre_write|
\item \verb|__volume_proto_chunk_allocate|
\end{compactitem}

\begin{lstlisting}[frame=single]
lichbd write /iscsi/p1/v1 hello -o 280375465082880
lichbd cat /iscsi/p1/v1 -o 280375465082880 -l 5
\end{lstlisting}

chunk allocate开销较大，即要申请磁盘空间，也涉及记录元数据到父节点。

遗留问题：
\begin{enumbox}
\item lich.inspect --stat极慢 (统计，load)
\item 分析内存占用量
\item clone
\item recovery
\item balance
\item 回收空间
\end{enumbox}

\subsection{副本数}

\section{操作}

\begin{enumbox}
\item create
\item rm
\item ls
\item info
\item resize
\item rename
\item mv
\item copy (read/write)
\item migrate (move all chunk)
\item duplicate (snapshot-based: clone/flatten)
\item import
\item export
\item mapping
\item \hl{IO}
\end{enumbox}

\subsection{create}

\subsection{QoS}

token bucket。IOPS与block size相关，两者乘积等于带宽。
如果各层发生IO聚合，则在流量守恒的情况下，显示IOPS有所不同。

IOPS必须假定一定的block size。
